
# Help info for ARM processors.

class Help_Documentation:
    def __init__(self):

        self.DESCRIPTION = (
            "An emulator for a TI msp430 cpu. \n"
            "Includes:\n"
            "  a simple debug interface with command line and GU Interface\n"
            "  a disassembler\n"
            "  a way to dump elf files in hex and ascii or to show \n"
            "    program headers, symbol tables etc.\n"
            "  supports legacy COFF files as generated by CCSv4 or ELF files\n"
            "    as generated by CCSv5\n"
            "Not yet available:\n"
            "  full symbol support. eg. b main\n"
            "  navigation in the disassembly window by clicking on an address\n"
            "  I/O memory\n"
            "Warning: The emulation is incomplete.\n\n"
            "Author  Pete Carr.\n"
            "February 2014")

        self.REF_DESCRIPTION = (
            "http://en.wikipedia.org/wiki/TI_MSP430#MSP430_Launchpad\n"
            "http://processors.wiki.ti.com/index.php/MSP430\n"
            "MSP430x2xx Family User's Guide. SLAU144H - April 2011\n"
            "TI Application Note SPRAA08 - April 2009. COFF format.\n"
            )


        self.ACKNOWLEDGEMENTS = (
            "pyelftools: Eli Bendersky (eliben@gmail.com)\n"
            "effbot.org: tkinter information (2.x)\n"
            "zetcode.com: tkinter information\n"
            "diveintopython.net: python information (2.x)\n"
            "http://www.java2s.com/Code/Python/GUI-Tk : tk examples (2.x)\n"
    
            )
        
        self.INSTRUCTIONS = (
            
"ff80   0040 0030 000f  (Hexadecimal mask)\n"
"opcode B/W  As	register Single-operand arithmetic\n"
"1000   B/W  As	register RRC Rotate right (1 bit) through carry\n"
"1080   0    As	register SWPB Swap bytes\n"
"1100   B/W  As	register RRA Rotate right (1 bit) arithmetic\n"
"1180   0    As register SXT Sign extend byte to word\n"
"1200   B/W  As	register PUSH Push value onto stack\n"
"1280   0    As	register CALL Subroutine call; \n"
"                        push PC and move source to PC\n"
"1300   0    0     0	 RETI Return from interrupt; \n"
"                        pop SR then pop PC\n"
"-------------------------------------\n"
"e000  1c00       3ff   (Hexadecimal mask)\n"  
"opcode+condition 10-bit signed offset\n"
"                       Conditional jump; PC = PC + 2*offset\n"
"2000  +0000	  3ff	JNE/JNZ Jump if not equal/zero\n"
"2000  +0400	  3ff	JEQ/JZ Jump if equal/zero\n"
"2000  +0800	  3ff	JNC/JLO Jump if no carry/lower\n"
"2000  +0c00	  3ff	JC/JHS Jump if carry/higher or same\n"
"2000  +1000	  3ff	JN Jump if negative\n"
"2000  +1400	  3ff	JGE Jump if greater or equal\n"
"2000  +1400	  3ff	JL Jump if less\n"
"2000  +1c00	  3ff	JMP Jump (unconditionally)\n"
"-------------------------------------\n"
"f000  0f00 0080 0040 0030 000f  (Hexadecimal mask)\n"
"opcode.source.Ad B/W  As  dest  Two-operand arithmetic\n"
"4000  src    Ad B/W  As   dest  MOV Move source to dest\n"
"5000  src    Ad B/W  As   dest  ADD Add source to dest\n"
"6000  src    Ad B/W  As   dest  ADDC Add source and carry to dest\n"
"7000  src    Ad B/W  As   dest  SUBC Subtract source from dest\n"
"                                  (with carry)\n"
"8000  src    Ad B/W  As   dest  SUB Subtract source from dest\n"
"9000  src    Ad B/W  As   dest  CMP Compare (pretend to subtract) source \n"
"                                  from dest\n"
"a000  src    Ad B/W  As   dest  DADD Decimal add source to dest\n"
"                                  (with carry)\n"
"b000  src    Ad B/W  As   dest  BIT Test bits of source AND dest\n"
"c000  src    Ad B/W  As   dest  BIC Bit clear (dest &= ~src)\n"
"d000  src    Ad B/W  As   dest  BIS Bit set (logical OR)\n"
"e000  src    Ad B/W  As   dest  XOR Exclusive or source with dest\n"
"f000  src    Ad B/W  As   dest  AND Logical AND source with dest\n"
"                                  (dest &= src)\n"
)
        
        self.MEMORY = (
        "Memory usage in a MSP430 is typically:\n\n"
        "0000-000f Processor function registers, eg. Interrupt Control\n"
        "0010-00ff 8-bit peripherals\n"
        "0100-01ff 16-bit peripherals\n"
        "0200-09ff Up to 2kbytes of RAM. (G2231 has 128 bytes, so 200-27f)\n"
        "0c00-0fff 1024 bytes of bootstrap loader ROM\n"
        "1000-10ff 256 bytes of data flash ROM\n"
        "1100-38ff Extended RAM in some models with > 2048 bytes)\n"
        "1100-ffff Up to 60k of program ROM\n"
        " Last 16 or 32 bytes are interrupt vectors:\n"
        " eg. on G2231, Lowest priority is at ffc0\n" 
        "     ffe4 => 18-<Port_1>\n"
        "     ffe8 => 20-USI or <TI_ISR_TRAP> which sets CPU_OFF in \n"
        "             the status register and jumps to self\n"
        "     fffc => 30-NMI interrupt vector points to <TI_ISR_TRAP>\n"
        "     fffe => 31-<_cint_00> code which calls <main> and then\n"
        "             finally, <abort> which jumps to self\n"
        " Program ROM is loaded in the high part of memory, eg. from e000-e800\n"
        "\n"
        )
        
    PERIPHERALS = (
        "Digital I/O Registers (Port P1).\n"
        "Register           Short Form   Addr Type       Initial State\n"
        "Input                    P1IN   020  Read only  -\n"
        "Output                   P1OUT  021  Read/write Unchanged\n"
        "Direction                P1DIR  022  Read/write Reset with PUC\n"
        "Interrupt Flag           P1IFG  023  Read/write Reset with PUC\n"
        "P1 Interrupt Edge Select P1IES  024  Read/write Unchanged\n"
        "Interrupt Enable         P1IE   025  Read/write Reset with PUC\n"
        "Port Select              P1SEL  026  Read/write Reset with PUC\n"
        "Port Select 2            P1SEL2 041  Read/write Reset with PUC\n"
        "Resistor Enable          P1REN  027  Read/write Reset with PUC\n"
        "Port 2 028 - 02f  P2SEL2 is 042\n"
        )
        
    def get(self, get_what):
        if get_what == "DESCRIPTION":
            return self.DESCRIPTION
        elif get_what == "REF_DESCRIPTION":
            return self.REF_DESCRIPTION
        elif get_what == "ACKNOWLEDGEMENTS":
            return self.ACKNOWLEDGEMENTS
        elif get_what == "INSTRUCTIONS":
            return self.INSTRUCTIONS
        elif get_what == "MEMORY":
            return self.MEMORY        
        else:
            return "Help requested unknown Documentation"
        
if __name__ == '__main__':
    """ If you run this as a main program some unit testing is done. """  
    
    hlp = Help_Documentation()
    print(hlp.get("DESCRIPTION"))
    print(hlp.get("REF_DESCRIPTION"))
    print(hlp.get("ACKNOWLEDGEMENTS"))
    print(hlp.get("INSTRUCTIONS"))
    print(hlp.get("MEMORY"))